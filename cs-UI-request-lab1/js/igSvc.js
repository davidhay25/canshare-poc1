//Utilities related to IG generation
angular.module("pocApp")

    .service('igSvc', function(modelsSvc) {

        return {



            makeFshForComp : function(comp,elements,hashElements) {
                let that = this
                //generate a fsh file for a composition.
                //the sections will be the top level entries. We use the composition to structure the model by
                //iterating over the sections, then the contents of the sections.
                //but because the composition can override the DG's, we need to iterate using the values in hashElements

               // console.log(elements)

                //elements is an array of {item:ed}
                //paths have structure {comp name}.{section}.{dg details}
                //pull out each DG from the section (where the 3rd segment is the same) and use the DG generation

                let currentDG = []  //the dg currently being examined
                let arCompFsh = []  //the fsh for each DG within each section - as well as the Comp header

                //let arLines = []
                let compName = comp.name
                arCompFsh.push(`Logical:\t ${compName}`)
                arCompFsh.push(`Id:\t\t ${compName}`)
                arCompFsh.push(`Title:\t\t "${comp.title}"`)
                if (comp.description) {
                    arCompFsh.push(`Description:\t "${comp.description}"`)
                }
                arCompFsh.push("")

                let initialSpacer = "  "  //all the lines generated by the DG need to be inset

                elements.forEach(function (item) {
                    let ed = item.ed
                    let path = ed.path
                    let ar = path.split('.')
                    let clone = angular.copy(item)      //as we'll be updating the path...

                    switch (ar.length) {
                        case 1:
                            //the first line of the comp
                            break
                        case 2:
                            //this is a section NZName 0..1 BackboneElement "A personâ€™s name details"

                            //Write out the FSH for the previously current DG
                            if (currentDG.length > 0) {
                                //all of the elements in the previous DG have been added to currentDG. Generate the FSH
                                let fsh = that.makeFshForDG(comp,currentDG,true,initialSpacer)
                                //console.log(fsh)
                                arCompFsh.push(fsh)
                                arCompFsh.push('')
                                currentDG.length = 0

                            }

                            //let clone = angular.copy(item)
                            //write out the first line of the DG
                           //temp clone.ed.path = adjustPath(clone.ed.path)
                           //temp currentDG.push(clone)

                            let lne = `* ${ed.name} ${ed.mult} BackboneElement "${ed.title}"`
                            arCompFsh.push(lne)
                            //arCompFsh.push("")
                            break
                        case 3:
                            //this is the contents of the DG

                            //let clone = angular.copy(item)
                            clone.ed.path = adjustPath(clone.ed.path)
                            currentDG.push(clone)
                            /*
                            if (currentDG.length > 0) {
                                //all of the elements in the previous DG have been added to currentDG. Generate the FSH
                                let fsh = that.makeFshForDG(comp,currentDG,true,initialSpacer)
                                console.log(fsh)
                                arCompFsh.push(fsh)
                                arCompFsh.push('')
                                currentDG.length = 0
                                let clone = angular.copy(item)
                                clone.ed.path = adjustPath(clone.ed.path)
                                currentDG.push(clone)
                            } else {
                                //this is the first pass through
                                currentDG.length = 0
                                let clone = angular.copy(item)
                                clone.ed.path = adjustPath(clone.ed.path)
                                currentDG.push(clone)
                            }
                            */
                            break
                        default:
                            //contents of the DG (and any z elements). Add to the current array
                            //remove the first 2 segments from the path
                            //let ar = item.ed.path.split('.')
                            //ar.splice(0,2)
                            item.ed.path = adjustPath(item.ed.path)
                            currentDG.push(item)
                    }





                })
                //add the last DG
                let fsh = that.makeFshForDG(comp,currentDG,true,initialSpacer)
                arCompFsh.push(fsh)

                //console.log(arCompFsh)
                return arCompFsh.join('\n')

                function adjustPath(path) {
                    let ar = path.split('.')
                    ar.splice(0,2)
                    return ar.join('.')
                }


/*

                return fsh//todo - finish later

                //so it's really a superset of what is done for DG's - we can't just re-use that code


                //hashElements has all elements by path todo - check that DG inheritance works properly
                console.log(comp)
                console.log(elements)
                let that = this


                
                comp.sections.forEach(function (sect) {
                    sect.items.forEach(function (item) {
                        let type = item.type[0]         //only have a single type
                        let fsh = that.makeFshForDG()

                    })
                })

*/

            },
            makeFshForDG : function (dg,elements,hideHeader,initialSpacer) {
                //generate a FSH file for a given DG
                //elements is the complete list of elements, including those derived from parents and
                //with child values updated from parents (if any)
                //if hideHeader is true then don't generate the LM header - this is being used by the composition generation

                initialSpacer = initialSpacer || ""     //when used by the comp.

                let fhirDT = modelsSvc.fhirDataTypes()
                let pathsToHide = []

                //remove all elements that have a mult of 0..0 or a parent
                let cleanedElements = []
                elements.forEach(function (item,inx) {
                    let ed = item.ed
                    let canAdd = true
                    if (ed.mult == '0..0') {
                        pathsToHide.push(ed.path)
                        canAdd = false
                    } else {
                        //is this a descendent of a hidden element
                        let path = ed.path
                        for (const p of pathsToHide) {
                            if (path.startsWith(p)) {
                                canAdd = false
                                break
                            }
                        }
                    }
                    if (canAdd) {
                        cleanedElements.push(item)
                    }

                })



                //now construct an object that represents the hierarchy (rather than a flat list of elements).
                let hash = {}
                let rootPath
                cleanedElements.forEach(function (item,inx) {
                    let ed = item.ed
                    let path = ed.path
                    hash[path] = {ed:ed,children:[]}  //add to the hash in case it is a parent...

                    //add the ed to the parent
                    let ar = ed.path.split('.')
                    if (ar.length > 1) {
                        ar.pop()
                        let parentPath = ar.join('.')
                        if (hash[parentPath] && hash[parentPath].children) {
                            hash[parentPath].children.push(hash[path])
                        }

                    } else {
                        rootPath = ar[0]
                    }

                })



               // now we can build the FSH document

                let arLines = []

                if (! hideHeader) {
                    //ensure the first letter is capitalized
                    let dgName = dg.name.charAt(0).toUpperCase() + dg.name.slice(1)
                    arLines.push(`Logical:\t ${dgName}`)
                    arLines.push(`Id:\t\t ${dgName}`)
                    arLines.push(`Title:\t\t "${dg.title}"`)
                    if (dg.description) {
                        arLines.push(`Description:\t "${dg.description}"`)
                    }
                    arLines.push("")
                }


                console.log(dg.name)
                console.log(hash)
                //the recursive processing function
                function processNode(ar,node,spacer) {
                    //ar.push(node.ed.path)
                    let arFshLine = getFsh(node.ed)     //will be an array of lines
                    arFshLine.forEach(function (lne) {
                        ar.push(spacer + lne)
                    })

                    if (node.children) {
                        //the first element (the root) has no fshLine. Checking here avoids over indenting
                        if (arFshLine.length > 0) {
                            spacer += "  "
                        }

                        node.children.forEach(function (child) {
                            processNode(ar,child,spacer)
                        })
                    }
                }

                if (hash[rootPath]) {
                    processNode(arLines,hash[rootPath],initialSpacer)
                }


                return arLines.join('\n')

                //get the fsh lines for an ed
                //can be more than one
                function getFsh(ed) {


                    if (ed.type) {
                        let arLne = []
                        /*
                        if (ed.mult == '0..0') {
                            return []
                        }
*/
                        let lne = ""
                        let type = ed.type[0]
                        //if the type is not a FHIR type, then it will be one of the DG. Replace it with 'BackboneElement'
                        if (fhirDT.indexOf(type) == -1 || type == 'Group') {
                            type = "BackboneElement"
                        }

                        let ar =  ed.path.split('.')
                        let name = ar[ar.length-1].replace(/slice:/g, '')

                        lne = `* ${name}`
                        let mult = ed.mult || '0..1'
                        lne += ` ${mult} ${type} `

                        if (ed.description) {
                            lne += `"${cleanString(ed.description)}"`
                        } else {
                            lne += `"${cleanString(ed.path)}"`  //description is required
                        }
                        arLne.push(lne)
                        if (ed.valueSet) {
                            let vs = ed.valueSet.replace(/\s/g, '') //remove any spaces
                            let lneVs =`* ${ar[ar.length-1]} from https://nzhts.digital.health.nz/fhir/ValueSet/${vs} (preferred)`
                            //console.log(ed.valueSet,lneVs)
                            arLne.push(lneVs)
                            //let lneVs = `item2 from http://hl7.org/fhir/ValueSet/contact-point-system (required)`

                        }

                        return arLne
                    } else {
                        return []
                    }

                }

                function cleanString(s) {
                    if (s) {
                        s = s.replace(/"/g, "'");
                        return s
                    } else {
                        return ""
                    }


                }



            },
            makeDocumentProfile : function (comp) {
                //generate a
            }

        }
    })